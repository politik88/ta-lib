{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"Use TA-Lib to add technical analysis to your own financial market trading applications <ul> <li> <p>200 indicators such as ADX, MACD, RSI, Stochastic, Bollinger Bands etc...  See complete list...</p> </li> <li> <p>Candlestick patterns recognition</p> </li> <li> <p>Core written in C/C++ with API also available for Python.</p> </li> <li> <p>Open-Source (BSD License). Can be freely integrated in your own open-source or commercial applications.</p> </li> </ul> <p>TA-Lib was release in 2001 for well-known algorithms that are still widely used &gt;20 years later. The code is stable and have passed the test of time. </p>"},{"location":"api/","title":"C/C++ API","text":"C/C++ API Documentation <p>1.0 Introduction</p> <p>2.0 How  to build and link to TA-Lib</p> <p>3.0 Technical Analysis Functions</p> <p>3.1 Direct call to a TA Function 3.2 Output Size <p>4.0 Advanced Features</p> 4.1 Abstraction layer 4.2 Unstable Period 4.3 Input Type: float vs. double 1.0 Introduction <p>All functions available to the end-user are documented here.</p> 2.0 How to build and link to TA-Lib <p>To use the library in C/C++ project, you just need to #include \"ta_libc.h\" and link to the static library corresponding to your type of application.</p> <p>All the required header file are in  ta-lib/c/include. Header files in other directories  should never be included by your application directly.</p> 2.1 Windows - MSVC and Visual Studio <p>Here is the list of variant of the static library currently supported:</p> <p> </p> Static Library Name Use runtime DLL?  Multithreaded? Debug info? ta_libc_csr.lib - - - ta_libc_csd.lib - - Yes ta_libc_cmr.lib - Yes - ta_libc_cmd.lib -\u00a0 Yes Yes ta_libc_cdr.lib Yes Yes - ta_libc_cdd.lib Yes Yes Yes <p> <p>Pre-compiled      version of these libraries is part of the MSVC package. If you wish to      re-build yourself the static libraries, makefiles can be found in ta-lib/c/make/&lt;ENV&gt;/win32/msvc.     These MSVC makefiles also works with Visual Studio 2005. The &lt;ENV&gt; is a 3 letter sub-directories (cmd, cmr, csd, csr, cdd      and cdr)      allowing to select the \"standard library runtime\" setting for your      application). Just type \"nmake\" or \"nmake /A\" to build all targets. The generated targets will be found in ta-lib/c/lib and ta-lib/c/bin.  <p>To rebuild from scratch do \"nmake clean\" and then \"nmake\" again.</p> <ul> <li> <p>The application without debug info are the speed optimized version. They cannot be trace for debugging though. <li> <p>Visual Studio 2005 project files can be found in  ta-lib/c/ide/vs2005 <li> <p>If you observe    link errors on Windows, verify that the \"Use runtime library\" setting in the      C/C++ Code generation tab is the same as your choice of static libraries. <li> <p>Link errors          will show up if your application does not links with wininet and    odbc32. These are provided with MSVC and Borland and should be found on your    system. 2.2 Windows/Free C++  Borland Compiler <ul> <li>Same as for Microsoft Visual C++, except: Makefiles are in ta-lib/c/make/&lt;ENV&gt;/win32/borland      and the cdd and cdr static library are not available. </li> <li>Execute the Borland \"make\" instead of the Microsoft \"nmake\". </li> <li>To build from scratch, do \"make clean\". This is needed particularly if you are switching between Borland and MSVC compiler because the object file formats are different (COFF=MSFT, OMF=Borland)</li> </ul> 2.3 Other Platforms 2.3.1 Linux Static Libraries <p>The SVN repository  and the Win32 packages contains multiple makefiles generated for multiple  platforms, including Linux. The makefiles are  found in ta-lib/c/make/&lt;ENV&gt;/linux/g++.</p> <p>The &lt;ENV&gt; is a 3 letter sub-directories (cmd,cmr,csd,csr) allowing to select an environment of development applicable to your application (see section 2.1). The cdd and cdr type does not apply to Linux.</p> <p>Just type \"make clean\" and \"make\" to build all targets. The generated target will be found in ta-lib/c/lib and ta-lib/c/bin.</p> <p>You will need to  link to 3 static libraries: ta-abstract, ta-func and ta-common</p> 2.3.2 All Unix Flavors Shared Libraries <p>Download the source code tar.gz package and perform the following as root:</p> <p>./configure ./make ./make install</p> <p>TA-Lib is contained  in a single shared library called \"libta-lib\" (name will vary depending of your  platform). With gcc you link using the switch \"-lta-lib\".</p> 2.4 Regression Testing (All Platform) <p>When building the  complete source tree, an application called \"ta_regtest\" is created in the ta-lib/c/bin  directory. This is a suite of tests to validate that the library you did compiled is behaving as expected  within your environment.</p> <p>Whenever you  re-compile the TA-Lib libraries, it is suggested to re-run ta_regtest. An internet connection is required  since web data fetching is one feature being tested.</p>  3.0 Technical Analysis Functions <p>Make sure TA_Initialize  was called once (and only once) prior to any other API functions.</p> <p>The individual TA function can be directly called. User who would like to integrate  the TA functions without prior knowledge of their parameters, should consider  the  abstraction layer interface.</p> <p>The source code of all the TA functions is in ta-lib/c/src/ta_func.</p> 3.1 Direct  call to a TA Function <p>Direct call could be  done through the interface defined in  ta-lib/c/include/ta_func.h</p> <p>All the TA functions are simple mathematical function. You provides the inputs with an array, and the function simply store the output in a caller provided output array. The TA functions are NOT allocating any space for the caller.  The number of data in the output  will NEVER exceed the number of elements requested to be calculated (with the startIdx and endIdx explained below).</p> <p>Here is an example:</p> <p>We will dissect the TA_MA function allowing to calculate a  simple moving average.</p> <p>TA_RetCode TA_MA( int\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 startIdx, int\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 endIdx, const double\u00a0inReal[], int\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  optInTimePeriod, int\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  optInMAType, int\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  *outBegIdx, int\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 \u00a0*outNbElement, double\u00a0\u00a0 \u00a0\u00a0\u00a0 outReal[], ) </p> <p>At first it appears that there is a lot of parameters, but do not be discourage, all functions are consistent and share the same parameter structure. The parameters are provided in  4 sections:</p> <ul> <li> <p>The output will be calculated only     for the range specified by startIdx to endIdx. <li> <p>   One or more data inputs are then specified. In that example there is only one    input. All inputs parameter     name starts with \"in\".  <li> <p>   zero or more optional inputs are specified     here. In that example     there is 2 optional inputs. These parameters allows to fine tune the function. If you do not care about a particular optIn    just  specify TA_INTEGER_DEFAULT or TA_REAL_DEFAULT (depending of the type). <li> <p>     One or more output are finally specified. In that example there is only one      output which is outReal (the parameters outBegIdx and    outNbElement are always specified once before the list of outputs). <p>This structure of parameters gives a lot of flexibility to make the function calculate ONLY the portion of required data. It is slightly complex, but it allows demanding user to manage efficiently the memory and the CPU processing.</p> <p>Lets say you wish to calculate a 30 day moving average using closing prices. The function call could look as follow:</p> <pre>TA_Real    closePrice[400];\nTA_Real    out[400];\nTA_Integer outBeg;\nTA_Integer outNbElement;</pre> <pre>/* ... initialize your closing price here... */</pre> <pre>retCode = TA_MA( 0, 399,\n                 &amp;closePrice[0],\n                 30,TA_MAType_SMA,\n                 &amp;outBeg, &amp;outNbElement, &amp;out[0] );</pre> <pre>/* The output is displayed here */\nfor( i=0; i &lt; outNbElement; i++ )\n   printf( \"Day %d = %f\\n\", outBeg+i, out[i] );\n</pre> <p>One important aspect  of the output are the outBeg and outNbElement. Even if it was requested to  calculate for the whole range (from 0 to 399), the moving average is not valid  until the 30th day. Consequently, the outBeg will be 29 (zero base)\u00a0 and  the outNbElement will be 400-29 = 371. Meaning only the first 371 elements of out are valid, and these could be calculated only starting at the 30th element of the input.</p> <p>As an alternative example, if you would have requested to calculate only in the \"125 to 225\" range (with startIdx and endIdx), the outBeg will be 125 and outNbElement will be 100. (the \"30\" minimum required is not an issue because we dispose of 125 closing price before the start of the requested range...). As you may have already understand, the \"out\" array will be written only for its first 100 elements. The rest will be left untouched.</p> <p>Here is another example. In that case we want to calculate a 14 bars exponential moving average only for 1 price bar in particular (say the last day of 300 price bar):\u00a0</p> <pre>TA_Real    closePrice[300];\nTA_Real    out;\nTA_Integer outBeg;\nTA_Integer outNbElement;</pre> <pre>/* ... initialize your closing price here... */</pre> <pre>retCode = TA_MA( 299, 299,\n                 &amp;closePrice[0],\n                 14, TA_MAType_EMA,\n                 &amp;outBeg, &amp;outNbElement, &amp;out );</pre> <p>In that example: outBeg will be 299,\u00a0 outNbElement will be 1, and only one value gets written into out.</p> <p>In the case that you do not provide enough data to even being able to calculate at least one value, outNbElement will be 0 and outBeg shall\u00a0 be ignored.</p> <p>If the input and  output of a TA function are of the same type, the caller can re-use the input  buffer for storing one of the output of the TA function. The following example will  work:</p> <pre>#define BUFFER_SIZE 100\nTA_Real buffer[BUFFER_SIZE];\n...\nretCode = TA_MA( 0, BUFFER_SIZE-1,\n                 &amp;buffer[0],\n                 30, TA_MAType_SMA,\n                 &amp;outBeg, &amp;outNbElement, &amp;buffer[0] );</pre> <p>Of course, the  input is overwritten, but this capability  diminish needs for temporary memory allocation for certain application. You can  assume this capability is true for all TA functions.</p> 3.2 Output Size <p> It is important that the output array is large enough. Depending of your needs,  you might find one of the following method useful to determine the output  allocation size. All these methods are consistent and works with all TA  functions:</p> Method Description Input Matching allocationSize = endIdx + 1;<p>     Pros: Easy to understand and implement.          Cons: Memory allocation unnecessary large when specifying small range. Range Matching allocationSize = endIdx - startIdx + 1;      Pros: Easy to implement.      Cons: Allocation slightly larger than needed. Example: for a 30 period SMA,      you will get 29 elements wasted because of the lookback. Exact Allocation lookback = TA_XXXX_Lookback( ... ) ;     temp = max( lookback, startIdx );     if( temp &gt; endIdx ) \u00a0\u00a0 allocationSize = 0; // No output     else  \u00a0\u00a0 allocationSize = endIdx - temp + 1;<p>     Pros: Optimal allocation algorithm.     Cons: Slightly more complex <p> </p> <p>A  function TA_XXXX_Lookback is provided for each TA function. Example: For TA_SMA,  there is a TA_SMA_Lookback.</p> <p>The lookback function indicates how many inputs are consume before the first  output can be calculated. Example: A simple moving average (SMA) of period 10  will have a lookback of 9.</p> 4.0 Advanced Features 4.1 Abstraction Layer <p>All the TA Function can be called using the interface defined in ta-lib/c/include/ta_abstract.h</p> <p>The abstraction layer is particularly interesting for an application who wishes to support the complete list of TA functions without having to re-write new code each time a new function is added to the TA-LIB. If you wish to simply integrate in your application a small number of specific function, you may be better to simply call these directly (see previous section).   Example: Lets say you are doing a charting software. When the user select a price bar, a side list offers blindly all the TA functions that could be applied to a price bar. The user selects one of these, then a dialog open for allowing to adjust the optional parameters (TA-LIB will tell your software which parameter are needed and the valid value range for each). Once all the parameter are set, you can call blindly the corresponding TA function. The returned information can then also blindly be drawn on the chart (some output flags allows to get some hint on how the data shall be drawn). The same \"abstract\" logic apply to all the TA functions. Some TA Functions works only on volume, or can work indifferently with any time series data (the open, close, another indicator...) All the applicable functions to the currently selected/available data can be determined through this \"virtual\" interface.  The abstraction layer is a complex, but powerful  interface.</p> 4.2 Unstable Period <p>Some TA functions provides different results depending of the \"starting point\" of the data being  involve. This is often referred as a function having memories. An example of such function is the Exponential Moving Average. It is  possible to control the unstable period (the amount of data to strip off) with TA_SetUnstablePeriod and  TA_GetUnstablePeriod.</p> 4.3 Input Type: float vs. double <p>For each technical analysis algorithm, there is one version of the function accepting the input as  array of float and another accepting array of double. The float version has a \"TA_S_\" suffix e.g.  for TA_MA there is an equivalent TA_S_MA function.</p> <p>TA_RetCode TA_MA( int\u00a0\u00a0\u00a0 startIdx, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  int\u00a0\u00a0\u00a0 endIdx, const double\u00a0 inReal[], \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  int\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 optInTimePeriod,  \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  TA_MAType\u00a0\u00a0\u00a0\u00a0 optInMAType, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  int\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 *outBegIdx, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  int\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 *outNbElement, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  double\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 outReal[] );  TA_RetCode TA_S_MA( int\u00a0\u00a0\u00a0 startIdx, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  int\u00a0\u00a0\u00a0 endIdx, const float inReal[], \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  int\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 optInTimePeriod, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  TA_MAType\u00a0\u00a0 optInMAType, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  int\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 *outBegIdx, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  int\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 *outNbElement, \u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0  double\u00a0\u00a0\u00a0\u00a0\u00a0 outReal[] ); </p> <p>Both version do all the  calculation using double e.g. when an element of a float array is accessed, it  is changed to double-precision. Consequently, both function will yield the same result.</p> <p>It is typical that  users have their price bar data as float and maintain all their intermediate  calculation as double. Having direct support for both type in TA-Lib is more  memory efficient.\u00a0 With only one type, the user would be potentially forced  to duplicate their input data in a new array of a different type prior to a TA  function call. </p>"},{"location":"faq/","title":"FAQ","text":"<p>Is TA-Lib maintained?</p> <p>Yes and No (depending of your perspective).</p> <p>The Good News</p> <p>Some projects depending on TA-Lib are still actively maintain.</p> <p>The C/C++ source code have remained in-use for &gt;20 years.</p> <p>The C/C++ portion of TA-Lib is stable. Therefore, there is not much maintenance needed anymore.</p> <p>The Bad News</p> <p>The big blocker for applying a few minor fix to the code is the lack of resources (and interest) to maintain C/C++/binaries packaging for various OS/platforms. Also, the developer admit being afraid to touch it and have to suddenly support multiple platforms issues/limitation...</p> <p>The Plan</p> <p>Revive TA-Lib as a Rust package with Python bindings (using PyO3 Maturin). These two languages have mature tooling for packaging and portable distribution.</p> <p>There is hope that this will be easier to maintain by the community on long term.</p> <p>Contact mario4tier on github if interested.</p> <p>Best place for support?</p> <p>Try these communities:</p> <ul> <li>https://github.com/ta-lib/ta-lib-python</li> <li>https://github.com/twopirllc/pandas-ta</li> </ul>"},{"location":"functions/","title":"Functions List","text":"TA Function Name AD Chaikin A/D Line ADOSC Chaikin A/D Oscillator ADX Average Directional Movement Index ADXR Average Directional Movement Index Rating APO Absolute Price Oscillator AROON Aroon AROONOSC Aroon Oscillator ATR Average True Range AVGPRICE Average Price BBANDS Bollinger Bands BETA Beta BOP Balance Of Power CCI Commodity Channel Index CDL2CROWS Two Crows CDL3BLACKCROWS Three Black Crows CDL3INSIDE Three Inside Up/Down CDL3LINESTRIKE Three Outside Up/Down CDL3STARSINSOUTH Three Stars In The South CDL3WHITESOLDIERS Three Advancing White Soldiers CDLABANDONEDBABY Abandoned Baby CDLADVANCEBLOCK Advance Block CDLBELTHOLD Belt-hold CDLBREAKAWAY Breakaway CDLCLOSINGMARUBOZU Closing Marubozu CDLCONCEALBABYSWALL Concealing Baby Swallow CDLCOUNTERATTACK Counterattack CDLDARKCLOUDCOVER Dark Cloud Cover CDLDOJI Doji CDLDOJISTAR Doji Star CDLDRAGONFLYDOJI Dragonfly Doji CDLENGULFING Engulfing Pattern CDLEVENINGDOJISTAR Evening Doji Star CDLEVENINGSTAR Evening Star CDLGAPSIDESIDEWHITE Up/Down-gap side-by-side white lines CDLGRAVESTONEDOJI Gravestone Doji CDLHAMMER Hammer CDLHANGINGMAN Hanging Man CDLHARAMI Harami Pattern CDLHARAMICROSS Harami Cross Pattern CDLHIGHWAVE High-Wave Candle CDLHIKKAKE Hikkake Pattern CDLHIKKAKEMOD Modified Hikkake Pattern CDLHOMINGPIGEON Homing Pigeon CDLIDENTICAL3CROWS Identical Three Crows CDLINNECK In-Neck Pattern CDLINVERTEDHAMMER Inverted Hammer CDLKICKING Kicking CDLKICKINGBYLENGTH Kicking - bull/bear determined by the longer marubozu CDLLADDERBOTTOM Ladder Bottom CDLLONGLEGGEDDOJI Long Legged Doji CDLLONGLINE Long Line Candle CDLMARUBOZU Marubozu CDLMATCHINGLOW Matching Low CDLMATHOLD Mat Hold CDLMORNINGDOJISTAR Morning Doji Star CDLMORNINGSTAR Morning Star CDLONNECK On-Neck Pattern CDLPIERCING Piercing Pattern CDLRICKSHAWMAN Rickshaw Man CDLRISEFALL3METHODS Rising/Falling Three Methods CDLSEPARATINGLINES Separating Lines CDLSHOOTINGSTAR Shooting Star CDLSHORTLINE Short Line Candle CDLSPINNINGTOP Spinning Top CDLSTALLEDPATTERN Stalled Pattern CDLSTICKSANDWICH Stick Sandwich CDLTAKURI Takuri (Dragonfly Doji with very long lower shadow) CDLTASUKIGAP Tasuki Gap CDLTHRUSTING Thrusting Pattern CDLTRISTAR Tristar Pattern CDLUNIQUE3RIVER Unique 3 River CDLUPSIDEGAP2CROWS Upside Gap Two Crows CDLXSIDEGAP3METHODS Upside/Downside Gap Three Methods CMO Chande Momentum Oscillator CORREL Pearson's Correlation Coefficient \u00ae DEMA Double Exponential Moving Average DX Directional Movement Index EMA Exponential Moving Average HT_DCPERIOD Hilbert Transform - Dominant Cycle Period HT_DCPHASE Hilbert Transform - Dominant Cycle Phase HT_PHASOR Hilbert Transform - Phasor Components HT_SINE Hilbert Transform - SineWave HT_TRENDLINE Hilbert Transform - Instantaneous Trendline HT_TRENDMODE Hilbert Transform - Trend vs Cycle Mode KAMA Kaufman Adaptive Moving Average LINEARREG Linear Regression LINEARREG_ANGLE Linear Regression Angle LINEARREG_INTERCEPT Linear Regression Intercept LINEARREG_SLOPE Linear Regression Slope MA All Moving Average MACD Moving Average Convergence/Divergence MACDEXT MACD with controllable MA type MACDFIX Moving Average Convergence/Divergence Fix 12/26 MAMA MESA Adaptive Moving Average MAX Highest value over a specified period MAXINDEX Index of highest value over a specified period MEDPRICE Median Price MFI Money Flow Index MIDPOINT MidPoint over period MIDPRICE Midpoint Price over period MIN Lowest value over a specified period MININDEX Index of lowest value over a specified period MINMAX Lowest and highest values over a specified period MINMAXINDEX Indexes of lowest and highest values over a specified period MINUS_DI Minus Directional Indicator MINUS_DM Minus Directional Movement MOM Momentum NATR Normalized Average True Range OBV On Balance Volume PLUS_DI Plus Directional Indicator PLUS_DM Plus Directional Movement PPO Percentage Price Oscillator ROC Rate of change : ((price/prevPrice)-1)*100 ROCP Rate of change Percentage: (price-prevPrice)/prevPrice ROCR Rate of change ratio: (price/prevPrice) ROCR100 Rate of change ratio 100 scale: (price/prevPrice)*100 RSI Relative Strength Index SAR Parabolic SAR SAREXT Parabolic SAR - Extended SMA Simple Moving Average STDDEV Standard Deviation STOCH Stochastic STOCHF Stochastic Fast STOCHRSI Stochastic Relative Strength Index SUM Summation T3 Triple Exponential Moving Average (T3) TEMA Triple Exponential Moving Average TRANGE True Range TRIMA Triangular Moving Average TRIX 1-day Rate-Of-Change (ROC) of a Triple Smooth EMA TSF Time Series Forecast TYPPRICE Typical Price ULTOSC Ultimate Oscillator VAR Variance WCLPRICE Weighted Close Price WILLR Williams' %R WMA Weighted Moving Average"},{"location":"install/","title":"Install","text":"<p>Check https://pypi.org/project/TA-Lib </p> <p>Read the \"dependencies\" section for various installation and troubleshooting tips.</p> <p>Source Package (with makefiles):</p> <ul> <li>ta-lib-0.4.0-src.tar.gz</li> </ul> <p>Some variants:</p> <ul> <li>Java ta-lib-0.4.0.jar</li> <li>RPM  ta-lib-0.4.0-1.i386.rpm</li> </ul>"},{"location":"wrappers/","title":"Wrappers","text":"<p>Not satisfied with the C/C++ version? Please check these alternative projects that wrap and enhance TA-Lib:</p> <ul> <li>ta-lib-python</li> <li>pandas-ta</li> </ul>"}]}